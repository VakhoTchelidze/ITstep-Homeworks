
#ესაა ლისტის კომპონენტის მონაცემი - ცალკეული ნოუდი სადაც უნდა შევინახოთ ინფორმაცია(შესანახი მონაცემი და ლინკი მომდევნო მონაცემთან)
class ListNode:
    def __init__(self, value):
        #აქ ვინხავთ მონაცემს
        self.value = value
        #აქ ვინახავთ მომდევნო ელემენტს
        self.next = None

#ეს არის უშუალოდ მწკრივის კლასი
class LinkedList:
    #შემნისას ვამატებთ საწყის ელემენტს
    def __init__(self, value):
        #ჰედის მონაცემს ვინახავთ ლისტ ნოუდის კლასში სადაც შექმნილი გვაქვს ნოუდის სტრუქტურა
        self.head = ListNode(value)
        #აქ ვინახავთ ლისტის სიგრძეს
        self.length = 1

    #ლისტში ელემენტის ჩამატების ფუნქცია
    def append(self, value):
        #დროებითად საწყის ელემენტს ვინახავთ ქურენთ ნოუდის ცვლადში რადგან შევძლოთ საწყისი ელემენტიდან ბოლო ელემენტამდე მისვლა
        current_node = self.head

        #ბოლო ელემენტია ის რომლის ნექსტ ელემენტიც არის None, ამ ვაილ ლუპით გადავდივართ ელემენტიდან ელემენტზე მანამ სანამ არ მივალთ ბოლო ელემენტტთან
        while current_node.next is not None:
            current_node = current_node.next

        # როცა ბოლო ელემენტზე მივალთ ლისტნოუდის კლასის დამხარებით დავამატებთ ახალ ელემენტს
        new_node = ListNode(value)
        #ქურენთ ნოუდი ვაილ ლუპის მერე იქნება ბოლო ელემენტზე ამიტომ ბოლო ელემენტის ნექსთს რომელიც ნონია ჩავანაცვლებთ ახალი ელემენტით
        current_node.next = new_node
        #აქ ვითვლით ლისტის სიგრძეს
        self.length += 1

    #მონაცემის ჩამატების ფუნქცია - აქ სამი სცენარია - როცა ჩამატება გვინდა თავში, ბოლოში და სხვა ადგილას.
    def insert(self, value, index):
        #აქ ვინთვლით ლისტის ინდექსებს
        last_index = self.length - 1
        # ეს გვჭირდება ინდექსაციისთვის
        i = 0

        #თუ თავში გვინდა ჩამატება
        if index == 0:
            # ძველი მონაცემის ცვლადში ვინახავთ ჰედს
            old_head = self.head
            # შემდეგ ვამატებთ ნოუდს და ვინახავთ ჰედის ცვლადში
            self.head = ListNode(value)
            #ახალი ჰედის ნექსტში ვინახავთ ძველ ჰედს
            self.head.next = old_head
            #ვამატებთ სიგრძის ცვლადს 1-ს
            self.length += 1

        # თუ ვამატებთ სიის ბოლოს
        elif index == last_index+1:
            # უბრალოდ აპენდ ფუნქციით ვამატებთ ახალ მონაცემს
            self.append(value)

        # როცა სიის შუაში ვამატებთ
        elif 0 < index < last_index + 1:
            #ქურენთ ნოუდის ცვლადში ვინახავთ ჰედს რომ შევძლოთ ნექსთ ფუნქციით იმდენჯერ გადასვლა სანამ სასურველ ადგილზე არ მივალთ
            current_node = self.head

            #ვაილ ციკლით ვითვლით გადასვლებს იქამდე დანამ i არ იქნება ჩვენ მიერ მითითებული იდექსის წინ
            while i != index-1:
                current_node = current_node.next
                i += 1
            # ვაილ ლუპის ბოლოს ქურენთ ნოუდში გვექნება ის ელემენტი რომლის შემდეგაც უნდა ჩაისვას ჩენ მიერ ახლად შექმნილი ელემენტი

            # ნიუ ნოუდში ვინახავთ ახალ ელემენტს
            new_node = ListNode(value)
            # ახალი ელემენტის მონდევნო ელემენტები იქნება არსებული ნოუდის მონდევნო ელემენტები
            new_node.next = current_node.next
            #და არსებულის  მომდევნოზე ჩაისმება ახალი ელემენტის
            current_node.next = new_node
            #აქ გავზრდის ლისტის სიგრძეს
            self.length += 1

        # თუ ჩვენ მიერ მითითებული ინდექსი მეტია ლისტის ზომაზე
        elif index > last_index + 1 or index < 0:
            print("Index Is Out Of Range")


    # სიიდან წაშლის ფუქნცია - აქაც როგორც ჩამატაბის ფინქვიაში გვაქვს სამი სცენარი
    def remove(self, index):
        # ვითვლით ინდექსებს
        last_index = self.length - 1
        # ეს ცვლადი საჭიროა ინდექსაციისთვის
        i = 0

        if index == 0:
            # თუ პირველი ელემენტის წაშლა გვინდა უბრალოდ ვეუბნებით რომ ახალი ჰედ ელემენტი უნდა გახდეს არსებული ჰედ ელემენტის მონდევნო ელემენტი
            self.head = self.head.next
            #აქ ვამცირებთ ლისტის ზომას
            self.length -= 1

        #ბოლო ელემენტის ამოშლა
        elif index == last_index:
            # ქურენთ ნოუდში ვინახავთ საწყის ელემენტს რომ შევძლოთ ბოლოს წინა ელემენტზე მოხვედრა
            current_node = self.head

            # ვაილ ლუპი ეშვება იქამდე სანამ ბოლოს წინა ელემენტზე არ მოვხვდებით
            while i < last_index - 1:
                current_node = current_node.next
                i += 1

            # ბოლოს წინა ელემენტის მონდევნო ლემენტს ვანაცვლებთ ცარიელი სიმრავლით
            current_node.next = None
            self.length -= 1

        #თუ ამოსაშლელი ელემენტი არც ჰედია და არც ბოლო
        elif 0 < index < last_index:
            # ვინახავთ ქურენტ ნოუდ ცვლადში საწყის ელემენტს რომ შევძლოთ გადასვლა სასურველ ელემენტზე
            current_node = self.head

            # ეშვება ვაილ ლუპი არ მოვხვდებით სასურველი ელემენტის წიინა ელემენტზე
            while i != index - 1:
                current_node = current_node.next
                i += 1

            # წაშლილი ელემენტის ცვლადში ვინახავთ იმ ელემენტს რომლის წაშლაც გვინდა ანუ ქურენტ-ელემენტის მომდევნო ელემენტს
            deleted_element = current_node.next
            #ქურენტ ელემენტის მომდევნო ელემენს ვხდით წასაშლელი ელემენტის მომდევნო ელემენტს
            current_node.next = deleted_element.next
            # სიის ზომას ვაცირებთ ერთით
            self.length -= 1


        # თუ ჩვენ მიერ მითითებული ინდექსი სიის ზომის გარეთაა
        elif index > last_index + 1 or index < 0:
            print("Index Is Out Of Range")



    # ამ ფუნქციას ვიყენებთ ლისტის დაპრინტვისთვის
    def printList(self):
        # ქურენთ ნოუდში ვინახავთ ჰედს რომ შევძლოთ იტერაცია
        current_node = self.head
        # ვპრინტავთ პირველი ელემენტის მონაცემს
        print(f"{current_node.value} ->", end="")

        # შემდეგ ვაილ ლუპით გადავდივათ შემდეგ ელემენტებზე სანამ ბოლოზე არ მივალთ და თან ვპრინტავთ
        while current_node.next is not None:
            current_node = current_node.next
            print(f" {current_node.value} ->", end="")